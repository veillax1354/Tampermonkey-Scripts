// ==UserScript==
// @name         Copy YouTube Comment Threads to Clipboard (YouTube API)
// @namespace    http://tampermonkey.net/
// @version      2024-05-28
// @description  Requires a YouTube Data API key on line 84, which is obtainable from: ( https://console.cloud.google.com/ ). On top-level comments, you can click a button to copy the entire thread (which includes the comment and all of its replies, if there are any) to your clipboard. The button appears when you hover over just to the right of where it shows how long ago a comment was posted.
// @author       TheDerpyDude
// @match        https://www.youtube.com/watch?v=*
// @match        https://www.youtube.com/live/*
// @match        https://www.youtube.com/shorts/*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=youtube.com
// @grant        unsafeWindow
// ==/UserScript==

(function () {
    'use strict';

    // Removes elements previously generated by the script to allow it to refresh
    document.querySelectorAll("#derpy").forEach(e => e.remove());
    if (typeof commentDerpyUpdater !== 'undefined') {
        commentDerpyUpdater.disconnect();
        commentDerpyUpdater = undefined;
    }

    // Hopefully this should make the script work if you copy/paste it into the console as well as running it in TamperMonkey.
    var windowAccess = (typeof GM_info == "undefined") ? window : unsafeWindow;

    // All text formatting occurs here
    windowAccess.threadToText = function (comment, replies) {

        let format = true // <-- Set to true for plaintext, false for yaml
            ? "plaintext" : "yaml"
        ;

        let commentSnippet = comment.items[0].snippet.topLevelComment.snippet;

        if (format == "plaintext") {
            let text =
                `Comment by ${
                commentSnippet.authorDisplayName
                }: ${
                commentSnippet.textDisplay}`
            ;
            if (replies)
                for (const reply of replies.items) {
                    text += `\n\n\tReply by ${
                        reply.snippet.authorDisplayName
                        }: ${
                        reply.snippet.textDisplay}`
                    ;
                }
            ;
            return text;
        } else if (format == "yaml") {
            let text =
                `tagged: tag.derpy-youtube-comment-thread-018f93e2-f169-795c-881c-3f70edfa2806\ncomment:\n  author: ${
                commentSnippet.authorDisplayName
                }\n  body: ${
                commentSnippet.textDisplay
                }\n  replies:`
            ;
            if (replies)
                for (const reply of replies.items) {
                    text +=
                        `\n    - reply:\n      author: ${
                        reply.snippet.authorDisplayName
                        }\n      body: ${
                        reply.snippet.textDisplay
                        }\n      tags: >-\n        unused for now`
                    ;
                }
            ;
            text += '\n  tags: >-\n      unused for now';
            return text;
        } else console.error("In the script's threadToText function, choose either 'plaintext' or 'yaml' to format the text to.");
    }

    // This gets the thread data and formats it with threadToText
    windowAccess.copyThread = async function (button) {

        // Get an API Key from Google's Youtube Data API v3
        // Make sure when creating credentials to choose API Key
        // https://console.cloud.google.com/apis/api/youtube.googleapis.com
        // ✨✨✨ Your YouTube Data API key goes here ✨✨✨
        let key = "";

        // Scrape dat comment ID :) 
        let headerAuthorElement = button.parentElement.parentElement.parentElement;
        let commentLink = headerAuthorElement.querySelector("span > a[href*=watch]");
        commentLink ??= headerAuthorElement.querySelector("span > a[href*=live]");
        let commentID = commentLink.href.split('lc=')[1];

        let comment = await (await fetch(
            `https://youtube.googleapis.com/youtube/v3/commentThreads?` +
            `id=${commentID}&` +
            `part=snippet&` +
            `part=replies&` +
            `textFormat=plainText&` +
            `maxResults=100&` +
            `key=${key}`
        )).json();
        let replies = await (await fetch(
            `https://youtube.googleapis.com/youtube/v3/comments?` +
            `parentId=${commentID}&` +
            `part=snippet&` +
            `textFormat=plainText&` +
            `maxResults=100&` +
            `key=${key}`
        )).json();
        // Continue requesting replies until they're all received
        let nextPageTokenError = false;
        while (replies.nextPageToken) {
            let replies2 = await (await fetch(
                `https://youtube.googleapis.com/youtube/v3/comments?` +
                `parentId=${commentID}&` +
                `pageToken=${replies.nextPageToken}&` +
                `part=snippet&` +
                `textFormat=plainText&` +
                `maxResults=100&` +
                `key=${key}`
            )).json();
            replies.items.push(...replies2.items);
            if (replies.nextPageToken == replies2.nextPageToken) {
                nextPageTokenError = true;
                break;
            }
            replies.nextPageToken = replies2.nextPageToken;
        }

        let threadText = windowAccess.threadToText(comment, replies);
        console.log(threadText);
        if (nextPageTokenError)
            console.error("The same nextPageToken was received twice, so not all thread replies could be included")
        ;
        setClipboard(threadText);
        console.log(`Retrieved and copied #${replies.items.length} replies in a thread`);

        // Dunno where I got this whole function lol, some of it from ChatGPT and maybe some from StackOverflow.
        // Some of it checks if the document is focused because otherwise clipboard.write errors.
        async function setClipboard(text) {
            const type = "text/plain";
            const blob = new Blob([text], { type });
            const data = [new ClipboardItem({ [type]: blob })];

            // Function to attempt clipboard write
            const writeClipboard = async () => {
                try {
                    await navigator.clipboard.write(data);
                } catch (err) {
                    console.error("Failed to copy comments to clipboard:", err);
                }
            };

            // Check if the document is already focused
            if (document.hasFocus()) {
                await writeClipboard();
            } else {
                // Wait for the document to become focused
                const handleFocus = async () => {
                    if (document.hasFocus()) {
                        document.removeEventListener('visibilitychange', handleFocus);
                        await writeClipboard();
                    }
                };
                document.addEventListener('visibilitychange', handleFocus);
            }
        }
    }

    windowAccess.appendDerpyButton = function (target) {
        target.insertAdjacentHTML('beforeend',
            `<div id="derpy" style="opacity: 0%;" onmouseover="this.style.opacity='100%';" onmouseout="this.style.opacity='0%';">
                <span dir="auto" id="published-time-text" class="style-scope ytd-comment-view-model">&nbsp;~</span>
                <span dir="auto" id="published-time-text" class="style-scope ytd-comment-view-model">
                    <a class="yt-simple-endpoint style-scope ytd-comment-view-model" onclick="copyThread(this);">copy thread</a>
                </span>
            </div>`
        );
    }

    // Places the copy thread button to the right of all currently loaded buttons' age text.
    // The buttons aren't visible until you hover over them
    document.querySelectorAll("#comment #header-author").forEach(element => appendDerpyButton(element));

    // Shoutout to this library for making a (somewhat more) simple way to run code on elements only after they've loaded.
    // Actually nevermind. This dang code kept being weird even in a simple test environment.
    // It probably would've been easier to just set something up from scratch instead of keep debugging this,
    // but I'll use it anyway since now it works at least. ;-;
    // https://gist.github.com/sidneys/ee7a6b80315148ad1fb6847e72a22313
    // https://greasyfork.org/en/scripts/374849-library-onelementready-es7

    let queryForElements = (selector, callback) => {
        const attributeName = 'was-queried';
        let elementList = document.querySelectorAll(selector) || [];
        elementList.forEach((element) => {
            if (element.hasAttribute(attributeName)) { return; }
            element.setAttribute(attributeName, 'true');
            callback(element);
        });
    }

    let onElementReady = (selector, findOnce = false, callback = () => { }) => {
        return new Promise((resolve) => {
            // Initial Query
            queryForElements(selector, (element) => {
                resolve(element);
                callback(element);
            });

            // Continuous Query
            const observer = new MutationObserver(() => {
                // DOM Changes detected
                queryForElements(selector, (element) => {
                    resolve(element);
                    callback(element);

                    if (findOnce) { observer.disconnect(); }
                });
            });

            // Observe DOM Changes
            observer.observe(document.documentElement, {
                attributes: false,
                childList: true,
                subtree: true
            });
        });
    }

    // Wait for Elements with a given CSS selector to enter the DOM.
    // Returns a Promise resolving with new Elements, and triggers a callback for every Element.
    //     @param {String} selector - CSS Selector
    //     @param {Boolean=} findOnce - Stop querying after first successful pass
    //     @param {function=} callback - Callback with Element
    //     @returns {Promise<Element>} - Resolves with Element
    onElementReady("ytd-comments#comments > ytd-item-section-renderer#sections > div#contents", true, () => {

        // Use a MutationObserver to add buttons to all new comments that
        // load after first running the script
        var commentDerpyUpdater = new MutationObserver(mutations => {
            mutations.forEach(mutation => {

                // What to do with each mutation
                if (mutation.addedNodes.length)
                    mutation.addedNodes.forEach(addedNode => {

                        // What to do with each addedNode
                        if (addedNode.nodeName == "YTD-COMMENT-THREAD-RENDERER")
                            setTimeout(addedNode => {
                                appendDerpyButton(addedNode.querySelector("#header-author"));
                                // console.log(
                                //     `derpyButton appended to child #${
                                //         // Handy debug code to check what number child a top level comment is
                                //         Array.from(addedNode.parentNode.children).indexOf(addedNode)
                                //     }:`,
                                //     addedNode
                                // );
                            }, 1000, addedNode);
                        ;
                    });
                ;
            });
        });

        commentDerpyUpdater.observe(
            document.querySelector("ytd-comments#comments > ytd-item-section-renderer#sections > div#contents"),
            { childList: true }
        );
    });
})();