// ==UserScript==
// @name         Copy YouTube Comment Threads to Clipboard (YouTube API)
// @namespace    http://tampermonkey.net/
// @version      2024-05-19
// @description  Requires a YouTube Data API key on line 35, which is obtainable from: ( https://console.cloud.google.com/ ). On top-level comments, you can click a button to copy the entire thread to your clipboard. The button appears when you hover over to the right of where it shows how long ago a comment was posted.
// @author       TheDerpyDude
// @match        https://www.youtube.com/*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=youtube.com
// @grant        unsafeWindow
// ==/UserScript==

(function () {
    'use strict';

    // Removes elements previously generated by the script to allow it to refresh
    document.querySelectorAll("#derpy").forEach(e => e.remove());
    if (typeof commentDerpyUpdater !== 'undefined') {
        commentDerpyUpdater.disconnect();
        commentDerpyUpdater = undefined;
    }

    // All text formatting occurs here
    unsafeWindow.threadToText = function (comment, replies) {
        let format = "yaml"; // Just choose the format here
        if (format == "plaintext") {
            let text = `Comment by ${comment.items[0].snippet.topLevelComment.snippet.authorDisplayName}: ${comment.items[0].snippet.topLevelComment.snippet.textDisplay}`;
            if (replies)
                for (const reply of replies.items) {
                    text += `\n\n\tReply by ${reply.snippet.authorDisplayName}: ${reply.snippet.textDisplay}`;
                }
            ;
            return text;
        } else if (format == "yaml") {
            let text = `tagged: tag.derpy-youtube-comment-thread-018f93e2-f169-795c-881c-3f70edfa2806\ncomment:\n  author: ${comment.items[0].snippet.topLevelComment.snippet.authorDisplayName}\n  body: ${comment.items[0].snippet.topLevelComment.snippet.textDisplay}\n  replies:\n`;
            if (replies)
                for (const reply of replies.items) {
                    text += `\n    - reply:\n      author: ${reply.snippet.authorDisplayName}\n      body: ${reply.snippet.textDisplay}\n      tags: >-\n        unused for now`;
                }
            ;
            text += '\n  tags: >-\n            unused for now';
            return text;
        } else console.log("What? That shouldn't be possible ðŸ¤”"); //nice
    }

    unsafeWindow.copyThread = async function(button) {

        /*Get an API Key from Google's Youtube Data API v3 - Make sure when creating credentials to choose API Key - https://console.cloud.google.com/apis/api/youtube.googleapis.com  */
        let key = ""; // âœ¨âœ¨âœ¨ Key goes here âœ¨âœ¨âœ¨

        let commentID = button.parentElement.parentElement.parentElement.querySelector("a[href*=watch]").href.split('lc=')[1];
        let comment = await (await fetch(`https://youtube.googleapis.com/youtube/v3/commentThreads?` +
                                         `id=${commentID}&` +
                                         `part=snippet&` +
                                         `part=replies&` +
                                         `textFormat=plainText&` +
                                         `maxResults=100&` +
                                         `key=${key}`
                                        )).json();
        let replies = await (await fetch(`https://youtube.googleapis.com/youtube/v3/comments?` +
                                         `parentId=${commentID}&` +
                                         `part=snippet&` +
                                         `textFormat=plainText&` +
                                         `maxResults=100&` +
                                         `key=${key}`
                                        )).json();
        // Continue requesting replies until they're all received
        while (replies.nextPageToken) {
            let replies2 = await (await fetch(`https://youtube.googleapis.com/youtube/v3/comments?` +
                                              `parentId=${commentID}&` +
                                              `pageToken=${replies.nextPageToken}&` +
                                              `part=snippet&` +
                                              `textFormat=plainText&` +
                                              `maxResults=100&` +
                                              `key=${key}`
                                             )).json();
            replies.items.push(...replies2.items);
            replies.nextPageToken = replies2.nextPageToken;
        }

        let threadText = unsafeWindow.threadToText(comment, replies);
        console.log(threadText);
        setClipboard(threadText);

        // Dunno where I got this whole function lol, some of it from ChatGPT and maybe some from StackOverflow.
        // Some of it checks if the document is focused because otherwise clipboard.write errors.
        async function setClipboard(text) {
            const type = "text/plain";
            const blob = new Blob([text], { type });
            const data = [new ClipboardItem({ [type]: blob })];

            // Function to attempt clipboard write
            const writeClipboard = async () => {
                try {
                    await navigator.clipboard.write(data);
                } catch (err) {
                    console.error("Failed to copy comments to clipboard:", err);
                }
            };

            // Check if the document is already focused
            if (document.hasFocus()) {
                await writeClipboard();
            } else {
                // Wait for the document to become focused
                const handleFocus = async () => {
                    if (document.hasFocus()) {
                        document.removeEventListener('visibilitychange', handleFocus);
                        await writeClipboard();
                    }
                };
                document.addEventListener('visibilitychange', handleFocus);
            }
        }
    }

    // Places the copy thread button to the right of all currently loaded buttons' age text.
    // The buttons aren't visible until you hover over them
    document.querySelectorAll("#comment #header-author").forEach(element => appendDerpyButton(element));

    unsafeWindow.appendDerpyButton = function(target) {
        target.innerHTML += `
    <div id="derpy" style="opacity: 0%;" onmouseover="this.style.opacity='100%';" onmouseout="this.style.opacity='0%';">
        <span dir="auto" id="published-time-text" class="style-scope ytd-comment-view-model">&nbsp;~</span>
        <span dir="auto" id="published-time-text" class="style-scope ytd-comment-view-model">
            <a class="yt-simple-endpoint style-scope ytd-comment-view-model" onclick="copyThread(this);">copy thread</a>
        </span>
    </div>`
    }

    // Shoutout to this library for making a (somewhat more) simple way to run code on elements only after they've loaded.
    // Actually nevermind. This dang code kept being weird even in a simple test environment.
    // It probably would've been easier to just set something up from scratch instead of keep debugging this,
    // but I'll use it anyway since now it works at least. ;-;
    // https://gist.github.com/sidneys/ee7a6b80315148ad1fb6847e72a22313
    // https://greasyfork.org/en/scripts/374849-library-onelementready-es7

    let queryForElements = (selector, callback) => {
        const attributeName = 'was-queried';
        let elementList = document.querySelectorAll(selector) || [];
        elementList.forEach((element) => {
            if (element.hasAttribute(attributeName)) { return; }
            element.setAttribute(attributeName, 'true');
            callback(element);
        });
    }
    let onElementReady = (selector, findOnce = false, callback = () => {}) => {
        return new Promise((resolve) => {
            // Initial Query
            queryForElements(selector, (element) => {
                resolve(element);
                callback(element);
            });

            // Continuous Query
            const observer = new MutationObserver(() => {
                // DOM Changes detected
                queryForElements(selector, (element) => {
                    resolve(element);
                    callback(element);

                    if (findOnce) { observer.disconnect(); }
                });
            });

            // Observe DOM Changes
            observer.observe(document.documentElement, {
                attributes: false,
                childList: true,
                subtree: true
            });
        });
    }
    let waitForKeyElements = (selector, callback, findOnce) => onElementReady(selector, findOnce, callback);

    // Wait for Elements with a given CSS selector to enter the DOM.
    // Returns a Promise resolving with new Elements, and triggers a callback for every Element.
    //
    // @param {String} selector - CSS Selector
    // @param {Boolean=} findOnce - Stop querying after first successful pass
    // @param {function=} callback - Callback with Element
    // @returns {Promise<Element>} - Resolves with Element
    //
    onElementReady("ytd-comments#comments > ytd-item-section-renderer#sections > div#contents", true, () => {

        // Use a MutationObserver to add buttons to all new comments that
        // load after first running the script
        var commentDerpyUpdater = new MutationObserver(mutations => {mutations.forEach(mutation => {

            // What to do with each mutation
            if (mutation.addedNodes.length)
                mutation.addedNodes.forEach(addedNode => {

                    // What to do with each addedNode
                    if (addedNode.nodeName == "YTD-COMMENT-THREAD-RENDERER")
                        setTimeout(addedNode => {
                            appendDerpyButton(addedNode.querySelector("#header-author"));
                            // console.log(
                            //     `derpyButton appended to child #${
                            //         // Handy debug code to check what number child a top level comment is
                            //         Array.from(addedNode.parentNode.children).indexOf(addedNode)
                            //     }:`,
                            //     addedNode
                            // );
                        }, 1000, addedNode);
                    ;
                });
            ;
        });});

        commentDerpyUpdater.observe(
            document.querySelector("ytd-comments#comments > ytd-item-section-renderer#sections > div#contents"),
            {childList: true}
        );
    });
})();
